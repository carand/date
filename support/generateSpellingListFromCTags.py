#!/usr/bin/env python

# This software is in public domain. It is intended to be customized by
# its nature. This program is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
# Please report bugs in VimDoxSpell to Vytautas.Shaltenis@gmail.com.
#
# VimDoxSpell's home page is at
# <http://rtfb.lt/projects/vim-dox-spell/>.
#
# MAINTAINER: Vytautas Saltenis <Vytautas.Shaltenis@gmail.com>
#
# Copyright (C) 2008, Vytautas Saltenis

import os
import sys
import getopt
import errno
import xml.dom.minidom

PROJECT_DIR= '/home/cmd/repos/cpp/sofis_new/rfid'



def get_word_list_from_tags(tags_file):
    """Parses tags file, taking all the identifiers and stashing them
    into a list.
    """

    tags = open(tags_file).readlines()
    tags = filter(lambda l: not l.startswith('!'), tags)
    words = map(lambda t: t.split('\t')[0], tags)
    return words


def write_word_list(list, file):
    """Writes a given list of words to a given file. One word per line.
    """

    f = open(file, 'w')
    map(lambda w: f.write(w + '\n'), list)


def get_text(nodelist):
    """Retrieves a text between XML tags.
    """

    rc = ''

    for node in nodelist:
        if node.nodeType == node.TEXT_NODE:
            rc = rc + node.data

    return rc


def parse_doxygen_index(file):
    """Parses the index file generated by doxygen. The information that
    is of interest there, are the names of the function groups, so that
    they can also be added to the dictionary of known words. Returned
    in a list.
    """

    contents = open(file).read()
    dom = xml.dom.minidom.parseString(contents)
    compounds = dom.getElementsByTagName('compound')
    groupNames = []

    for c in compounds:
        if c.attributes['kind'].nodeValue == 'group':
            group = get_text(c.getElementsByTagName('name')[0].childNodes)
            groupNames.append(group)

    return groupNames


def write_empty_spl_file(home_dir):
    """This one is tricky, if you don't know how Vim deals with its
    spelling dictionaries. For a proper explanation, refer to Vim
    documentation, and here it is sufficient to say, that I need a
    file 'fromtags.utf-8.spl', that is an empty dictionary. Vim will
    then not complain about being unable to find a dictionary. And all
    the real dictionary will be handled through another file,
    'fromtags.utf-8.add.spl', which is generated by this program.
    """

    empty_spl_file = 'VIMspell2\xff' + '\x00' * 13
    spl_filename = my_meta_spell_file + '.utf-8.spl'
    empty_spl_file_path = os.path.join(home_dir, spl_filename)
    open(empty_spl_file_path, 'wb').write(empty_spl_file)


def read_things(home_dir):
    """Reads tags and XML files to gather all the information needed
    to put into our dictionary of identifiers.
    """

    words = []

    if my_tags_file:
        words.extend(get_word_list_from_tags(my_tags_file))
        print('tags read.')

    if my_index_xml:
        words.extend(parse_doxygen_index(my_index_xml))
        print('doxygen index read.')

    if len(words) == 0:
        print('Warning: there is no words to be added to dictionary...')
        print('Check if -t or -i options are specified.')

    return words


def write_things(home_dir, things):
    """Writes the plain text list of identifiers and then calls Vim
    to generate an actual dictionary for its use.
    """

    dictFile = home_dir + '/' + my_meta_spell_file + '.utf-8.add'
    write_word_list(things, dictFile)
    print('word list written.')

    write_empty_spl_file(home_dir)

    # The following command line calls Vim to generate the binary
    # dictionary file it will actually be using, not the plain text
    # one we've just written with write_word_list.
    cmd = 'vim --cmd ":set encoding=utf-8" --cmd ":mkspell! %s" --cmd ":q"'
    os.system(cmd % (dictFile))
    print('spl generated.')


def clear_spell_files(home_dir):
    flist = [
             home_dir + '/' + my_meta_spell_file + '.utf-8.spl',
             home_dir + '/' + my_meta_spell_file + '.utf-8.add',
             home_dir + '/' + my_meta_spell_file + '.utf-8.add.rws',
             home_dir + '/' + my_meta_spell_file + '.utf-8.add.spl',
             home_dir + '/' + my_meta_spell_file + '.utf-8.aff',
             home_dir + '/' + my_meta_spell_file + '.aff',
             home_dir + '/' + my_meta_spell_file + '.dic',
            ]

    # TODO: maybe we need to check if '.utf-8.spl' is empty spell file...
    # to prevent removing real spell files.

    for file in flist:
        if os.path.exists(file):
            print(" ...removing: %s" % (file))
            os.remove(file)


def usage():
    """Prints usage information.
    """

    print("""Usage: %(prog)s [-t <file>] [-o <file>] [-i <file>] <metaspell>
       %(prog)s --clear <metaspell>
    -t <file>   tags file generated by Exuberant Ctags
    -i <file>   index xml file generated by Doxygen
    -o <file>   output directory, default is the current working directory. if thie output dir does not exists, it will be created.
    --clear     clear all generated spell files from your vim configuration
                directory
    -h, --help  this help
    <metaspell> basename of the spell file, that will be stored the output directory
                directory:
                    <output dir>/<metaspell>.utf-8.spl
                    <output dir>/<metaspell>.utf-8.add
    """ % {'prog': sys.argv[0]})


def check_meta_spell_file_arg(args):
    global my_meta_spell_file

    if len(args) != 1:
        print("Metaspell file not specified. Nothing to do.\n")
        usage()
        sys.exit(2)
    else:
        my_meta_spell_file = args[0]



def create_aspell_dict(home_dir):

    myDict = home_dir + '/' + my_meta_spell_file + '.utf-8.add'
    cmd = 'aspell --encoding=UTF-8 --dont-validate-words --lang=de create master ' + myDict +'.rws <' + myDict
    os.system(cmd)

def create_hunspell_dicts(home_dir):
    file = home_dir + '/' + my_meta_spell_file
    base_list = file + '.utf-8.add'
    dict_file = file + '.dic'
    aff_file = file + '.aff'
    # create an empt aff file
    os.system("touch " + aff_file)
    # generate dict
    cmd = 'wc -l ' + base_list + ' > ' + dict_file
    os.system(cmd)
    cmd = 'sort ' + base_list + ' | uniq >> ' + dict_file
    os.system(cmd)
    # add a emty line
    # f = open(word_list, 'a')
    # f.write('\n\n')
    # f.close()






def check_and_create_outdir(out_dir):
    print("output directory: %s" %out_dir)
    try:
        os.makedirs(out_dir)
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise


def main():
    global my_tags_file, my_index_xml

    # home_dir = os.environ['HOME']

    try:
        opts, args = getopt.getopt(sys.argv[1:], 'o::t::i::h', ['help', 'clear'])
    except getopt.GetoptError, err:
        print(str(err) + '\n')
        usage()
        sys.exit(2)

    my_tags_file = None
    my_index_xml = None
    my_output_dir = os.getcwd()
    print(" runtime dir: %s" % my_output_dir )

    for opt, arg in opts:
        if opt == '-t':
            my_tags_file = arg
        elif opt == '-i':
            my_index_xml = arg
        elif opt == '-o':
            my_output_dir = arg
        elif opt == '--clear':
            check_meta_spell_file_arg(args)
            clear_spell_files(my_output_dir)
            sys.exit()
        elif opt in ('-h', '--help'):
            usage()
            sys.exit()
        else:
            assert False, "unhandled option"

    check_and_create_outdir(my_output_dir)
    check_meta_spell_file_arg(args)
    things = read_things(my_output_dir)
    write_things(my_output_dir, things)
    create_aspell_dict(my_output_dir)
    create_hunspell_dicts(my_output_dir)
    print('Done.')

if __name__ == '__main__':
    main()
